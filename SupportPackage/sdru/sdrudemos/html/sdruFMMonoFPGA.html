
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>FPGA Targeting with USRP&reg; N210 Hardware</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-02-27"><meta name="DC.source" content="sdruFMMonoFPGA.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><style>
.open_example { 
    padding:0px 0px 1px 0px;
    margin:20px;
    font-size:0.9em;
    border:1px solid #aeaeae;
    display:block;
    float:right;
    border-radius:5px; -moz-border-radius:5px; -webkit-border-radius:5px;
    background: #ffffff; /* Old browsers */
    background: -moz-linear-gradient(top, #FFFFFF 0%, #E6E6E6 100%); /* FF3.6+ */	
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#FFFFFF), color-stop(100%,#E6E6E6)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top, #FFFFFF 0%,#E6E6E6 100%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* IE10+ */
    background: linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#FFFFFF', endColorstr='#E6E6E6',GradientType=0 ); /* IE6-9 */
}

.open_example:hover {
    background: #f3f3f3; /* Old browsers */
    background: -moz-linear-gradient(top, #f3f3f3 0%, #d7d7d7 100%); /* FF3.6+ */    
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f3f3f3), color-stop(100%,#d7d7d7)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top, #f3f3f3 0%,#d7d7d7 100%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* IE10+ */
    background: linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#f3f3f3', endColorstr='#d7d7d7',GradientType=0 ); /* IE6-9 */
} 

.open_example a { 
    padding:6px 10px; 
    line-height:130%;
    text-decoration:none;
    float:left;
}
      </style><div class="open_example"><a href="matlab:sdruFMMonoFPGA">Open this Example</a></div><div class="content"><h1>FPGA Targeting with USRP&reg; N210 Hardware</h1><!--introduction--><p>This example shows how to add code to the FPGA in USRP&reg; N210 hardware that implements FM demodulation from Simulink.  You will generate HDL code and implement it on the FPGA using the HDL Coder workflow advisor.</p><p>This example relies on the digital downconverter (DDC) already present in the FPGA within the USRP&reg; N210.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Requirements</a></li><li><a href="#2">About FPGA Targeting with USRP&reg; N210</a></li><li><a href="#4">Model the FM Demodulator for HDL</a></li><li><a href="#7">Simulation Model of Baseband Algorithm in Real Time</a></li><li><a href="#10">Generate HDL and Implement on FPGA</a></li><li><a href="#16">Burn FPGA with New Bit Stream</a></li><li><a href="#17">Verify FPGA Implementation</a></li><li><a href="#20">Copyright Notice</a></li></ul></div><h2>Requirements<a name="1"></a></h2><div><ul><li>Simulink&reg;</li><li>HDL Coder&#8482;</li><li>USRP&reg; N210 motherboard with WBX or TVRX daughter card connected to your computer</li><li>Xilinx ISE Tools installed</li></ul></div><h2>About FPGA Targeting with USRP&reg; N210<a name="2"></a></h2><p>This example shows you how to prototype the baseband algorithms on FPGA with real-time hardware. You may also use this workflow to speed up your Simulink simulations with real-time hardware.</p><p>The following may be noted about this workflow:</p><div><ol><li>This workflow only applies to single-channel receivers that use the digital downconverter (DDC) already present in the FPGA within the USRP&reg; N210.  This example will not change the existing DDC code.</li><li>FPGA code for transmit paths and additional receive paths will not be present in the USRP&reg; FPGA. This allows more FPGA area for implementation of baseband algorithms from Simulink.</li></ol></div><h2>Model the FM Demodulator for HDL<a name="4"></a></h2><img vspace="5" hspace="5" src="sdruFMMonoFPGA_01.png" alt=""> <p>The example model <a href="matlab:sdruFMMonoFPGA">sdruFMMonoFPGA</a> shows how FM Demodulator can be modeled for HDL code generation and implementation on FPGA. The original model <a href="matlab:sdruFMMono">sdruFMMono</a> can be converted to its new form as follows:</p><div><ul><li>Convert to Sample-Based  - You must model the <tt>FM_Demod_FPGA</tt> subsystem intended for HDL code generation in sample based manner for scalar processing. You can convert the frame based input signals to scalar by using Unbuffer block. To get back to frame based mode you can use Buffer block. Within this boundary of Unbuffer/Buffer blocks, the system operates in scalar mode and is good for HDL Code generation.</li></ul></div><div><ul><li>Convert to Fixed Point - The complex I/Q baseband signal input to FM Demodulator is converted to fixed point with 16 bit word length and 17 bit fraction length. The FM demodulator is implemented as a complex difference operation between consecutive complex samples. Arctan is implemented using cordic in parallel with 8 stages and a latency of 10.</li></ul></div><div><ul><li>Conform to USRP&reg; FPGA Interface - The output of FM Demodulator must be two 16 bits signed signals in order to match the output of existing digital down converter in the FPGA. This is done by modeling another subsystem <tt>FPGA to host</tt> (not shown above) within <tt>FM_Demod_FPGA</tt> which converts the 32 bit FM Demodulator output to 16 bit complex integers.</li></ul></div><h2>Simulation Model of Baseband Algorithm in Real Time<a name="7"></a></h2><p>You can simulate the model with real time data from hardware to verify your baseband algorithm in Simulink. Buffering may be enabled for the SDRu Receiver block to ensure that the samples are contiguous for a specified number of frames.</p><p>To enable buffering for this example:</p><div><ol><li>Open SDRu Receiver block mask</li><li>Check box for <b>Enable burst mode</b></li><li>Enter 1000 for the <b>Number of frames in burst</b></li></ol></div><p>You can simulate this model in accelerator mode to verify that the fixed point FM Demodulator model plays the FM radio to the tuned frequency. You will notice that the model plays for small segments with pauses in between, when the SDRu Receiver block pauses for buffering the next burst of data.</p><h2>Generate HDL and Implement on FPGA<a name="10"></a></h2><p><img vspace="5" hspace="5" src="sdrufmmonohdlwfa.png" alt=""> </p><p>You can follow the step by step instructions to generate HDL for subsystem <tt>FM_Demod_FPGA</tt>:</p><div><ol><li>Open the workflow by right-clicking on <tt>FM_Demod_FPGA</tt> subsystem and select HDL Code and HDL Workflow Advisor.</li><li>On step 1.1 select <b>Customization for the USRP&reg; Device</b> for <b>Target workflow</b> and your USRP&reg; N210 Board for <b>Target Platform</b></li><li>Run steps 2.1 to 2.5 to make sure your model is compatible.</li><li>On step 3.1, select the HDL Code generation options. Specifically on step 3.1.2 select <b>Synchronous</b> for Reset type, <b>Active-high</b> for <b>Reset asserted level</b> and <b>Single</b> for <b>Clock  inputs</b>. These HDL options are set so as to match with the rest of USRP&reg; FPGA code.</li><li>On step 3.2 select <b>Generate RTL Code</b></li><li>On step 4.0 <b>Generate FPGA Implementation</b>, <b>USRP&reg; Source File Folder</b> is already populated with the path to USRP&reg; FPGA root directory. The relevant USRP&reg; FPGA code was downloaded during the installation from Ettus Research&#8482; UHD&#8482; Mirror site.</li></ol></div><p>By running step 4.0, the HDL Workflow Advisor creates a new Xilinx ISE project and adds the following:</p><div><ul><li>All the necessary files from the USRP&reg; FPGA repository</li><li>The generated HDL files for <tt>FM_Demod_FPGA</tt> subsystem.</li></ul></div><p>If no error is found in FPGA project generation and syntax checking, FPGA programming file generation process will start in an external command shell. You can monitor the external shell for the progress of implementation processes. A message indicating successful completion of programing file generation is printed out in the shell upon completion.</p><h2>Burn FPGA with New Bit Stream<a name="16"></a></h2><p>You can burn the generated FPGA binary using the burner utility, as provided by Ettus Research&#8482; and as per the instructions in Firmware Update section of <a href="../../help/index.html">Getting Started</a>. In USRP-N2XX Net Burner GUI, for FPGA image you will provide generated FPGA binary <tt>usrp_n210_r4_fpga_mw.bin</tt> (or <tt>usrp_n210_r2_fpga_mw.bin</tt>) from project location like <tt>hdl_prj\usrp_prj</tt>. For Firmware image, you will use the original firmware (usrp_n210_fw_bin) since no changes are made to firmware during FPGA targetting.</p><h2>Verify FPGA Implementation<a name="17"></a></h2><p>You can now open <a href="matlab:sdruFMMonoFPGAretarget">sdruFMMonoFPGAretarget</a>  model to verify your FPGA implementation of FM Mono Demodulator.</p><img vspace="5" hspace="5" src="sdruFMMonoFPGA_02.png" alt=""> <p>You can quickly build the retarget model from the original sdruFMMonoFPGA model by removing the <tt>FM_Demod_FPGA</tt> subsystem along with Unbuffer/Buffer blocks and inserting the Complex to Real-Imag block. A few notes about the retarget model:</p><div><ul><li>This model does not have FM Demodulator as that is implemented in FPGA.</li><li>The complex inputs received are converted into one 32 bit signed number with 29 fraction bits in order to match the output of the FM Demodulator (as modeled before in sdruFMMonoFPGA model). This is done by reusing the <tt>Unpack FPGA outputs</tt> subsystem from sdruFMMonoFPGA model.</li><li>The model operates in frame mode and buffering is disabled.</li></ul></div><p>You can run the model in real-time to listen the radio. The FPGA in the USRP&reg; N210 hardware has been re-targeted with FM Demodulator. This concludes the example for targeting FM Demodulator on the FPGA.</p><h2>Copyright Notice<a name="20"></a></h2><p>USRP&reg; and Ettus Research&#8482; are trademarks of National Instruments Corp.</p><p class="footer">Copyright 2011-2012 The MathWorks, Inc.<br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br><br>
		  MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.
      </p></div><!--
##### SOURCE BEGIN #####
%% FPGA Targeting with USRP(R) N210 Hardware 
% This example shows how to add code to the FPGA in USRP(R) N210 hardware
% that implements FM demodulation from Simulink.  You will generate HDL
% code and implement it on the FPGA using the HDL Coder workflow advisor.
%
% This example relies on the digital downconverter (DDC) already present in
% the FPGA within the USRP(R) N210.

% Copyright 2011-2012 The MathWorks, Inc.

%% Requirements
% * Simulink(R)
% * HDL Coder(TM)
% * USRP(R) N210 motherboard with WBX or TVRX daughter card connected to
% your computer
% * Xilinx ISE Tools installed
%
%% About FPGA Targeting with USRP(R) N210 
%
% This example shows you how to prototype the baseband algorithms on FPGA
% with real-time hardware. You may also use this workflow to speed up your
% Simulink simulations with real-time hardware.
%
% The following may be noted about this workflow:
%
%%
% # This workflow only applies to single-channel receivers that use the
% digital downconverter (DDC) already present in the FPGA within the
% USRP(R) N210.  This example will not change the existing DDC code.
% # FPGA code for transmit paths and additional receive paths will not
% be present in the USRP(R) FPGA. This allows more FPGA area for
% implementation of baseband algorithms from Simulink.
%% Model the FM Demodulator for HDL 
%
load_system('sdruFMMonoFPGA');
open_system('sdruFMMonoFPGA/FM Receiver');
set_param('sdruFMMonoFPGA', 'SimulationCommand', 'update');
%%
% The example model <matlab:sdruFMMonoFPGA sdruFMMonoFPGA> shows how FM
% Demodulator can be modeled for HDL code generation and implementation on
% FPGA. The original model <matlab:sdruFMMono sdruFMMono> can be converted
% to its new form as follows:
%% 
%
% * Convert to Sample-Based  - You must model the |FM_Demod_FPGA| subsystem 
% intended for HDL code generation in sample based manner for scalar
% processing. You can convert the frame based input signals to scalar by
% using Unbuffer block. To get back to frame based mode you can use Buffer
% block. Within this boundary of Unbuffer/Buffer blocks, the system
% operates in scalar mode and is good for HDL Code generation.
%
% * Convert to Fixed Point - The complex I/Q baseband signal input to FM
% Demodulator is converted to fixed point with 16 bit word length and 17
% bit fraction length. The FM demodulator is implemented as a complex
% difference operation between consecutive complex samples. Arctan is
% implemented using cordic in parallel with 8 stages and a latency of 10.
%
% * Conform to USRP(R) FPGA Interface - The output of FM Demodulator must
% be two 16 bits signed signals in order to match the output of existing
% digital down converter in the FPGA. This is done by modeling another
% subsystem |FPGA to host| (not shown above) within |FM_Demod_FPGA| which
% converts the 32 bit FM Demodulator output to 16 bit complex integers.
%
%% Simulation Model of Baseband Algorithm in Real Time
%%
% You can simulate the model with real time data from hardware to verify
% your baseband algorithm in Simulink. Buffering may be enabled for the
% SDRu Receiver block to ensure that the samples are contiguous for a
% specified number of frames. 
%%
% To enable buffering for this example:
%
% # Open SDRu Receiver block mask
% # Check box for *Enable burst mode*
% # Enter 1000 for the *Number of frames in burst*
%
% You can simulate this model in accelerator mode to verify that the fixed
% point FM Demodulator model plays the FM radio to the tuned frequency. You
% will notice that the model plays for small segments with pauses in
% between, when the SDRu Receiver block pauses for buffering the next burst
% of data.
%
%% Generate HDL and Implement on FPGA
%
% <<sdrufmmonohdlwfa.png>>
%
%%
% You can follow the step by step instructions to generate HDL for
% subsystem |FM_Demod_FPGA|:
%%
% # Open the workflow by right-clicking on |FM_Demod_FPGA| subsystem and
% select HDL Code and HDL Workflow Advisor.
% # On step 1.1 select *Customization for the USRP(R) Device* for *Target
% workflow* and your USRP(R) N210 Board for *Target Platform*
% # Run steps 2.1 to 2.5 to make sure your model is compatible.
% # On step 3.1, select the HDL Code generation options. Specifically on
% step 3.1.2 select *Synchronous* for Reset type, *Active-high* for *Reset
% asserted level* and *Single* for *Clock  inputs*. These HDL options are
% set so as to match with the rest of USRP(R) FPGA code.
% # On step 3.2 select *Generate RTL Code*
% # On step 4.0 *Generate FPGA Implementation*, *USRP(R) Source File Folder*
% is already populated with the path to USRP(R) FPGA root directory. 
% The relevant USRP(R) FPGA code was downloaded during the installation
% from Ettus Research(TM) UHD(TM) Mirror site.
%%
% By running step 4.0, the HDL Workflow Advisor creates a new Xilinx ISE project
% and adds the following:
%%
% * All the necessary files from the USRP(R) FPGA repository
% * The generated HDL files for |FM_Demod_FPGA| subsystem.
%
%%
% If no error is found in FPGA project generation and syntax checking, FPGA
% programming file generation process will start in an external command
% shell. You can monitor the external shell for the progress of
% implementation processes. A message indicating successful completion of
% programing file generation is printed out in the shell upon completion.
%
%% Burn FPGA with New Bit Stream
% You can burn the generated FPGA binary using the burner utility, as 
% provided by Ettus Research(TM) and as per the instructions in 
% Firmware Update section of <../../help/index.html Getting Started>. In
% USRP-N2XX Net Burner GUI, for FPGA image you will provide generated 
% FPGA binary |usrp_n210_r4_fpga_mw.bin| (or |usrp_n210_r2_fpga_mw.bin|) 
% from project location like |hdl_prj\usrp_prj|. For Firmware image, you
% will use the original firmware (usrp_n210_fw_bin) since no changes are
% made to firmware during FPGA targetting.
%
%% Verify FPGA Implementation
% You can now open <matlab:sdruFMMonoFPGAretarget sdruFMMonoFPGAretarget>
%  model to verify your FPGA implementation of FM Mono Demodulator.
load_system('sdruFMMonoFPGAretarget')
open_system('sdruFMMonoFPGAretarget/FM Receiver')
%%
% You can quickly build the retarget model from the original sdruFMMonoFPGA
% model by removing the |FM_Demod_FPGA| subsystem along with Unbuffer/Buffer
% blocks and inserting the Complex to Real-Imag block. A few notes about
% the retarget model:
%
% * This model does not have FM Demodulator as that is implemented in FPGA.
% * The complex inputs received are converted into one 32 bit signed number
% with 29 fraction bits in order to match the output of the FM Demodulator
% (as modeled before in sdruFMMonoFPGA model). This is done by reusing the
% |Unpack FPGA outputs| subsystem from sdruFMMonoFPGA model.
% * The model operates in frame mode and buffering is disabled.
%
%% 
% You can run the model in real-time to listen the radio. The FPGA in the
% USRP(R) N210 hardware has been re-targeted with FM Demodulator. This
% concludes the example for targeting FM Demodulator on the FPGA.
%
%% Copyright Notice
% USRP(R) and Ettus Research(TM) are trademarks of National Instruments
% Corp.
displayEndOfDemoMessage(mfilename)







##### SOURCE END #####
--></body></html>