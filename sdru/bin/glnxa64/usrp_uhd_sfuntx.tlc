%% File : usrp_uhd_sfuntx.tlc
%%
%% Description: 
%%   Simulink Coder TLC Code Generation file for usrp_uhd_sfuntx
%%
%% Simulink version      : 8.0 (R2011b Prerelease) 16-Feb-2011
%% TLC file generated on : 02-May-2011 16:38:58

/%
     %%%-MATLAB_Construction_Commands_Start
     def = legacy_code('initialize');
     def.SFunctionName = 'usrp_uhd_sfuntx';
     def.OutputFcnSpec = 'void sendData_c(  int32  work4, complex<int16> u1[], double u2, double u3, double u4, double u5, uint32 work5, DataPortDataTypeCapiEnumT work6, uint32 y1[1], UsrpErrorCapiEnumT work2[1], int8 work3[1024])';
     def.StartFcnSpec = 'void openDataConnection_c(  int8 p1[], BoardIdCapiEnumT p2, int8 work1[1024], int32 work4[1], UsrpErrorCapiEnumT work2[1], int8 work3[1024])';
     def.TerminateFcnSpec = 'void closeDataConnection_c(  int32 work4, UsrpErrorCapiEnumT work2[1], int8 work3[1024])';
     def.HeaderFiles = {'usrp_uhd_capi.hpp', 'usrp_sfun_setshs.hcpp'};
     def.Options.isMacro = true;
     def.Options.useTlcWithAccel = false;
     legacy_code('sfcn_tlc_generate', def);
     %%%-MATLAB_Construction_Commands_End
 %/

%implements usrp_uhd_sfuntx "C"

%% Function: FcnGenerateUniqueFileName ====================================
%%
%function FcnGenerateUniqueFileName(filename, type) void
  %%
  %assign isReserved = TLC_FALSE
  %foreach idxFile = CompiledModel.DataObjectUsage.NumFiles[0]
    %assign thisFile = CompiledModel.DataObjectUsage.File[idxFile]
    %if (thisFile.Name==filename) && (thisFile.Type==type)
      %assign isReserved = TLC_TRUE
      %break
    %endif
  %endforeach
  %if (isReserved==TLC_TRUE)
    %assign filename = FcnGenerateUniqueFileName(filename + "_", type)
  %endif
  %return filename
  %%
%endfunction

%% Function: BlockTypeSetup ===============================================
%%
%function BlockTypeSetup(block, system) void
  %%
  %% The Target Language must be C
  %if ::GenCPP==1
    %<LibReportFatalError("This S-Function generated by the Legacy Code Tool must be only used with the C Target Language")>
  %endif

  %assign ver = FEVAL("ver", "simulink")
  %assign factor = 1.0
  %assign slVer = 0.0
  %foreach idx = SIZE(ver.Version)[1]
    %if ISEQUAL(ver.Version[idx], ".")
      %assign factor = factor/10.0
    %else
      %assign slVer = slVer + %<ver.Version[idx]>*factor
    %endif
  %endforeach

  %if GenerateErtSFunction==1 && slVer < 6.21
    %<LibReportFatalError("S-Functions generated by the Legacy Code Tool (that use Simulink Object) may not be used in a model for which an ERT S-Function wrapper is being generated")>
  %endif

  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"

    %assign hFileName = FcnGenerateUniqueFileName("usrp_uhd_sfuntx_wrapper", "header")
    %assign hFileNameMacro = FEVAL("upper", hFileName)
    %openfile hFile = "%<hFileName>.h"
    %selectfile hFile
    #ifndef _%<hFileNameMacro>_H_
    #define _%<hFileNameMacro>_H_

    #include "tmwtypes.h"

    extern void usrp_uhd_sfuntx_wrapper_start( const int8_T *p1, const void *p2,  int8_T *work1, const uint32_T p3, const void *p4, const void *p5, const uint32_T p6,  int32_T *work4,  void *work2,  int8_T *work3);

    extern void usrp_uhd_sfuntx_wrapper_output(  int32_T work4, const cint16_T *u1, const real_T u2, const real_T u3, const real_T u4, const real_T u5,  uint32_T *y1,  void *work2,  int8_T *work3);

    extern void usrp_uhd_sfuntx_wrapper_terminate(  int32_T work4,  void *work2,  int8_T *work3);

    #endif
    %closefile hFile

    %assign cFileName = FcnGenerateUniqueFileName("usrp_uhd_sfuntx_wrapper", "source")
    %openfile cFile = "%<cFileName>.c"
    %selectfile cFile
    #include <string.h>
    #include "tmwtypes.h"
    #include "usrp_uhd_capi.hpp"

    void usrp_uhd_sfuntx_wrapper_start( const int8_T *p1, const void *p2,  int8_T *work1, const uint32_T p3, const void *p4, const void *p5, const uint32_T p6,  int32_T *work4,  void *work2,  int8_T *work3) {

      
      openDataConnection_c( (int8_T*)(p1), *(BoardIdCapiEnumT *) p2, (char *) work1, (uint32_T)(p3), *(DataPortDataTypeCapiEnumT *) p4, *(BufferModeCapiEnumT *) p5, (uint32_T)(p6), work4, (UsrpErrorCapiEnumT *) work2, work3);

    }

    void usrp_uhd_sfuntx_wrapper_output(  int32_T work4, const cint16_T *u1, const real_T u2, const real_T u3, const real_T u4, const real_T u5,  uint32_T *y1,  void *work2,  int8_T *work3) {


      sendData_c( work4, (void *)(u1), (real_T)(u2), (real_T)(u3), (real_T)(u4), (real_T)(u5), y1, (UsrpErrorCapiEnumT *) work2, work3);

    }

    void usrp_uhd_sfuntx_wrapper_terminate(  int32_T work4,  void *work2,  int8_T *work3) {


      closeDataConnection_c( work4, (UsrpErrorCapiEnumT *) work2, work3);

    }

    %closefile cFile

    %<LibAddToCommonIncludes("%<hFileName>.h")>
    %<LibAddToModelSources("%<cFileName>")>

  %else

    %<LibAddToCommonIncludes("usrp_uhd_capi.hpp")>

  %endif


  %%
%endfunction

%% Function: BlockInstanceSetup ===========================================
%%
%function BlockInstanceSetup(block, system) void
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
  %else
    %<LibBlockSetIsExpressionCompliant(block)>
  %endif
  %%
%endfunction

%% Function: Start ========================================================
%%
%function Start(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
    %assign p1_ptr = LibBlockParameterBaseAddr(p1)
    %assign p2_val = LibBlockParameter(p2, "", "", 0)
    %assign p3_val = LibBlockParameter(p3, "", "", 0)
    %assign p4_val = LibBlockParameter(p4, "", "", 0)
    %assign p5_val = LibBlockParameter(p5, "", "", 0)
    %assign p6_val = LibBlockParameter(p6, "", "", 0)
    %assign work1_ptr = LibBlockDWorkAddr(work1, "", "", 0)
    %assign work4_ptr = LibBlockDWorkAddr(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
    {
      BoardIdCapiEnumT p2_val = %<p2_val>;
      DataPortDataTypeCapiEnumT p4_val = %<p4_val>;
      BufferModeCapiEnumT p5_val = %<p5_val>;
      usrp_uhd_sfuntx_wrapper_start( %<p1_ptr>, (void *)&p2_val, %<work1_ptr>, %<p3_val>, (void *)&p4_val, (void *)&p5_val, %<p6_val>, %<work4_ptr>, %<work2_ptr>, %<work3_ptr>);
    }
  %else 
    %assign p1_ptr = LibBlockParameterBaseAddr(p1)
    %assign p2_val = LibBlockParameter(p2, "", "", 0)
    %assign p3_val = LibBlockParameter(p3, "", "", 0)
    %assign p4_val = LibBlockParameter(p4, "", "", 0)
    %assign p5_val = LibBlockParameter(p5, "", "", 0)
    %assign p6_val = LibBlockParameter(p6, "", "", 0)
    %assign work1_ptr = LibBlockDWorkAddr(work1, "", "", 0)
    %assign work4_ptr = LibBlockDWorkAddr(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %assign dhn = SFcnParamSettings.DHN

    %assign reqIdStr = LibGetFormattedBlockPath(block)
    %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
    { 
      char   newip[1024];
      size_t dhnlen;

    %% Set values on dwork for requesterId string
    strncpy((char *)%<work1_ptr>, "%<reqIdStr>", 1024);

    %if isRAccel
      strncpy(newip, (char *)%<p1_ptr>, 1024);
    %else
      dhnlen = strlen("%<dhn>");
      strncpy(newip, "%<dhn>", 1024); 
    %endif

    %% Set values on dworks for frameLength and dataPortDataType for use in the Outputs
    %% call
    %assign work5_ptr   = LibBlockDWorkAddr(work5, "", "", 0)
    %assign sigwidth    = LibBlockInputSignalWidth(0)
    %assign work6_ptr   = LibBlockDWorkAddr(work6, "", "", 0)
    %assign isComplex   = LibBlockInputSignalIsComplex(0)

    *%<work5_ptr>       = %<sigwidth>;

    %switch LibBlockInputSignalDataTypeId(0)
        %case tSS_DOUBLE
            *%<work6_ptr> = (%<isComplex>==1) ? DPortDTypeCDouble : DPortDTypeDouble;
            %break
        %case tSS_SINGLE
            *%<work6_ptr> = (%<isComplex>==1) ? DPortDTypeCSingle : DPortDTypeSingle;
            %break
        %case tSS_INT16
            *%<work6_ptr> = (%<isComplex>==1) ? DPortDTypeCInt16 : DPortDTypeInt16;
            %break
        %default
            *%<work6_ptr> = DPortDTypeCInt16;
            %break
    %endswitch 

    openDataConnection_c( newip, (BoardIdCapiEnumT)%<p2_val>, (char *) %<work1_ptr>, (uint32_T)%<p3_val>, (DataPortDataTypeCapiEnumT)%<p4_val>, (BufferModeCapiEnumT)%<p5_val>, (uint32_T)%<p6_val>, %<work4_ptr>, %<work2_ptr>, (char *) %<work3_ptr>);

    %% for rapid accelerator, report the error BUT NOT THROUGH THE BLOCK! (That'll
    %% just hang Simulink!)
    %if isRAccel 
        if (*%<work2_ptr> != UsrpDriverSuccess) {
            ssSetErrorStatus(rtS, (char *) %<work3_ptr>);
        }
    %% for stand-alone executables, just exit
    %else
    if (*%<work2_ptr> != UsrpDriverSuccess) {
        fprintf(stderr, "%s\n", (char *) %<work3_ptr>); 
        exit(-1);
    }
    %endif
  }
  /* end of code for  %<Type> (%<ParamSettings.FunctionName>): %<Name> */

  %endif 
  %%
%endfunction

%% Function: Outputs ======================================================
%%
%function Outputs(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
    %assign u1_ptr = LibBlockInputSignalAddr(0, "", "", 0)
    %assign u2_val = LibBlockInputSignal(1, "", "", 0)
    %assign u3_val = LibBlockInputSignal(2, "", "", 0)
    %assign u4_val = LibBlockInputSignal(3, "", "", 0)
    %assign u5_val = LibBlockInputSignal(4, "", "", 0)
    %assign y1_ptr = LibBlockOutputSignalAddr(0, "", "", 0)
    %assign work4_val = LibBlockDWork(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
    usrp_uhd_sfuntx_wrapper_output( %<work4_val>, %<u1_ptr>, %<u2_val>, %<u3_val>, %<u4_val>, %<u5_val>, %<y1_ptr>, %<work2_ptr>, %<work3_ptr>);
  %else 
    %assign u1_ptr = LibBlockInputSignalAddr(0, "", "", 0)
    %assign u2_val = LibBlockInputSignal(1, "", "", 0)
    %assign u3_val = LibBlockInputSignal(2, "", "", 0)
    %assign u4_val = LibBlockInputSignal(3, "", "", 0)
    %assign u5_val = LibBlockInputSignal(4, "", "", 0)
    %assign y1_ptr = LibBlockOutputSignalAddr(0, "", "", 0)
    %assign work4_val = LibBlockDWork(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %%
    sendData_c( %<work4_val>, (void*)%<u1_ptr>, (real_T)%<u2_val>,
            (real_T)%<u3_val>, (real_T)%<u4_val>, (real_T)%<u5_val>, %<y1_ptr>,
            %<work2_ptr>, (char *) %<work3_ptr>);

    %% for rapid accelerator, report the error BUT NOT THROUGH THE BLOCK! (That'll
    %% just hang Simulink!)
    %if isRAccel 
        if (*%<work2_ptr> != UsrpDriverSuccess) {
            ssSetErrorStatus(rtS, (char *) %<work3_ptr>);
        }
    %% for stand-alone executables, just exit
    %else
    if (*%<work2_ptr> != UsrpDriverSuccess) {
        fprintf(stderr, "%s\n", (char *) %<work3_ptr>); 
        exit(-1);
    }
    %endif
  %endif 
  %%
%endfunction

%% Function: Terminate ====================================================
%%
%function Terminate(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
    %assign work4_val = LibBlockDWork(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %%
    /* %<Type>(%<ParamSettings.FunctionName>): %<Name> */
    usrp_uhd_sfuntx_wrapper_terminate( %<work4_val>, %<work2_ptr>, %<work3_ptr>);
  %else 
   %assign work4_val = LibBlockDWork(work4, "", "", 0)
   %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
   %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
   %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
   closeDataConnection_c( %<work4_val>, %<work2_ptr>, (char *) %<work3_ptr>);

    %% for rapid accelerator, report the error BUT NOT THROUGH THE BLOCK! (That'll
    %% just hang Simulink!)
    %if isRAccel 
        if (*%<work2_ptr> != UsrpDriverSuccess) {
            ssSetErrorStatus(rtS, (char *) %<work3_ptr>);
        }
    %% for stand-alone executables, just exit
    %else
    if (*%<work2_ptr> != UsrpDriverSuccess) {
        fprintf(stderr, "%s\n", (char *) %<work3_ptr>); 
        exit(-1);
    }
    %endif
  %endif 
  %%
%endfunction

%% [EOF]
